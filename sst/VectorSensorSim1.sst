#############################################################################
# SST script to simulate signal generated by Vector Sensor beampatterns.
#
# This script creates a very simple scenario:
#   A stationary source emits broadband noise with a flat spectrum for
#   2 seconds.  A receiving sonar consisting of a line array of elements
#   hears this and generates channel-by-channel time series.  An "element"
#   here is defined as a 4-channel sensor; the channels are: 
#   - Omni
#   - Dipole-X
#   - Dipole-Y
#   - Dipole-Z
#   Thus, the total number of channels (independent time series) generated
#   is 4 X NumberOfElements
#
# See the file "VectorSensorBeams.sst" for details of the element
# simulation and the combined array.
# 
# Note that beampatterns have no bearing or frequency Dependence.
#############################################################################

##### Define the source's passive emissions #####
# Consists of broadband Gaussian white noise at a level of 
# 70 dB, flat over a 2 KHz frequency band (from 2-4 KHz)
# (This is quite arbitrary.)
new sourceNoise = BroadbandNoise {
#    isComplex = true     # complex baseband
#    frequency = 3000     # center freq.
    # Use real signal as BW is 2/3 of CF
    isComplex = false
	spectrumDB = TableFunction {
	    order = 1
    	table = (
		# f     dB
 		2000    -300
		2100 	70
		3900 	70
 		4000    -300
		)
	}
    # Run for 2 seconds
	times = { first=0; last=2; rate=10000 }   # 25% oversampling @ 4kHz

    # Interpolation order
    order = 11
}
# For testing: dump the generated noise signal
#CopySignal sourceNoise BareAsciiSignal{ file="SourceNoise.out" }

##### Define the Source #####
new theSource = Source {
   signal = sourceNoise
   # Put it 1 km north, at the same depth
   trajectory = { position = ( 1000 0 10 ) }
   # Assume noise is radiated omnidirectionally
   beams = (OmniBeam)
}
## NOTE:  At 1 km distance, with the source transmission beginning at 
##        time zero and a soundspeed of 1500 m/s, the first sound heard
#         will be at 2/3 seconds.

##### Define the ocean environment #####
new theOcean = Ocean {
    # Constant depth
    depth = 2000.0
    # Constant soundspeed
    soundspeed = 1500       # m/s
}

##### Define the eigenray model #####
new theEM = EigenrayModel {
    # No multipaths
    maximumSurfaceBounces = 0
    maximumBottomBounces = 0
}

##### Specify a receiver. #####
# Get the receive beams first
read "VectorSensorBeams.sst"
new theReceiver = Sonar {
    beams = vectorSensorArray   # from included file
    # Put it at the center of the coordinate system, 10 meters down
    trajectory = { position = ( 0 0 10 ) }
}

##### Describe what we want to do #####
# Create a "DirectSignal" from the source to the receiver
new result = DirectSignal {
    # Who's making the noise?
    source = theSource

    # Environment and propagation models
    ocean = theOcean
    eigenrayModel = theEM

    # Real output
	isComplex = false
    # Over what timespan and rate are we listening?
 	times = { first=0; last=2; rate=10000 }   # 25% oversampling

    # Who's hearing the noise?
    receiver = theReceiver
}

##### Generate file output #####

# Note the order of data in the files (assuming real output)
# - Column 1 = Time
# - Column 2 = Channel 1 = Element1 Omni
# - Column 3 = Channel 2 = Element1 DipoleX
# - Column 4 = Channel 3 = Element1 DipoleY
# - Column 5 = Channel 4 = Element1 DipoleZ
# - Column 6 = Channel 5 = Element2 Omni
# - Column 7 = Channel 6 = Element2 DipoleX
# - Column 8 = Channel 7 = Element2 DipoleY
# - Column 9 = Channel 8 = Element2 DipoleZ
# - Column 10 =Channel 9 =  Element3 Omni
# .......... ETC ..........

# ASCII format: Optional FYI
CopySignal result BareAsciiSignal { file="VectorSensorSignal.out" }
# SIO format: Required for Matlab display tools
CopySignal result SIOSignal { file="VectorSensorSignal.sio" }

##### Optional Sanity Check #####
# The output from the omni channels and the corresponding X-dipoles
# should be identical
new omni1 = SelectChannel{
    inSignal = SIOSignal { file="VectorSensorSignal.sio" }
    channel = 1
}
new xd1 = SelectChannel{
    inSignal = SIOSignal { file="VectorSensorSignal.sio" }
    channel = 2
}
CompareSignals{ 
    standard = omni1
    signal = xd1
}
# ... could also check channels (5,6) , (9,10) , etc...
